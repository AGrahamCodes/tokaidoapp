<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>GCDAsyncSocket Class Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.1 (build 858)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">CocoaAsyncSocket 0.0.1 </a></h1>
				<a id="developerHome" href="../index.html">Dustin Voss and Robbie Hanson</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">GCDAsyncSocket Class Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	<option value="class_methods">Class Methods</option>
	
	<option value="//api/name/CRData">&nbsp;&nbsp;&nbsp;&nbsp;+ CRData</option>
	
	<option value="//api/name/CRLFData">&nbsp;&nbsp;&nbsp;&nbsp;+ CRLFData</option>
	
	<option value="//api/name/LFData">&nbsp;&nbsp;&nbsp;&nbsp;+ LFData</option>
	
	<option value="//api/name/ZeroData">&nbsp;&nbsp;&nbsp;&nbsp;+ ZeroData</option>
	
	<option value="//api/name/getHost:port:fromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ getHost:port:fromAddress:</option>
	
	<option value="//api/name/hostFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ hostFromAddress:</option>
	
	<option value="//api/name/portFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ portFromAddress:</option>
	
	
	
	
	<option value="instance_methods">Instance Methods</option>
	
	<option value="//api/name/acceptOnInterface:port:error:">&nbsp;&nbsp;&nbsp;&nbsp;- acceptOnInterface:port:error:</option>
	
	<option value="//api/name/acceptOnPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- acceptOnPort:error:</option>
	
	<option value="//api/name/autoDisconnectOnClosedReadStream">&nbsp;&nbsp;&nbsp;&nbsp;- autoDisconnectOnClosedReadStream</option>
	
	<option value="//api/name/connectToAddress:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:error:</option>
	
	<option value="//api/name/connectToAddress:viaInterface:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:viaInterface:withTimeout:error:</option>
	
	<option value="//api/name/connectToAddress:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:withTimeout:error:</option>
	
	<option value="//api/name/connectToHost:onPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:error:</option>
	
	<option value="//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:viaInterface:withTimeout:error:</option>
	
	<option value="//api/name/connectToHost:onPort:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:withTimeout:error:</option>
	
	<option value="//api/name/connectedAddress">&nbsp;&nbsp;&nbsp;&nbsp;- connectedAddress</option>
	
	<option value="//api/name/connectedHost">&nbsp;&nbsp;&nbsp;&nbsp;- connectedHost</option>
	
	<option value="//api/name/connectedPort">&nbsp;&nbsp;&nbsp;&nbsp;- connectedPort</option>
	
	<option value="//api/name/delegate">&nbsp;&nbsp;&nbsp;&nbsp;- delegate</option>
	
	<option value="//api/name/delegateQueue">&nbsp;&nbsp;&nbsp;&nbsp;- delegateQueue</option>
	
	<option value="//api/name/disconnect">&nbsp;&nbsp;&nbsp;&nbsp;- disconnect</option>
	
	<option value="//api/name/disconnectAfterReading">&nbsp;&nbsp;&nbsp;&nbsp;- disconnectAfterReading</option>
	
	<option value="//api/name/disconnectAfterReadingAndWriting">&nbsp;&nbsp;&nbsp;&nbsp;- disconnectAfterReadingAndWriting</option>
	
	<option value="//api/name/disconnectAfterWriting">&nbsp;&nbsp;&nbsp;&nbsp;- disconnectAfterWriting</option>
	
	<option value="//api/name/enableBackgroundingOnSocket">&nbsp;&nbsp;&nbsp;&nbsp;- enableBackgroundingOnSocket</option>
	
	<option value="//api/name/getDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- getDelegate:delegateQueue:</option>
	
	<option value="//api/name/init">&nbsp;&nbsp;&nbsp;&nbsp;- init</option>
	
	<option value="//api/name/initWithDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:delegateQueue:</option>
	
	<option value="//api/name/initWithDelegate:delegateQueue:socketQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:delegateQueue:socketQueue:</option>
	
	<option value="//api/name/initWithSocketQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithSocketQueue:</option>
	
	<option value="//api/name/isConnected">&nbsp;&nbsp;&nbsp;&nbsp;- isConnected</option>
	
	<option value="//api/name/isDisconnected">&nbsp;&nbsp;&nbsp;&nbsp;- isDisconnected</option>
	
	<option value="//api/name/isIPv4">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4</option>
	
	<option value="//api/name/isIPv4Enabled">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4Enabled</option>
	
	<option value="//api/name/isIPv4PreferredOverIPv6">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4PreferredOverIPv6</option>
	
	<option value="//api/name/isIPv6">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6</option>
	
	<option value="//api/name/isIPv6Enabled">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6Enabled</option>
	
	<option value="//api/name/isSecure">&nbsp;&nbsp;&nbsp;&nbsp;- isSecure</option>
	
	<option value="//api/name/localAddress">&nbsp;&nbsp;&nbsp;&nbsp;- localAddress</option>
	
	<option value="//api/name/localHost">&nbsp;&nbsp;&nbsp;&nbsp;- localHost</option>
	
	<option value="//api/name/localPort">&nbsp;&nbsp;&nbsp;&nbsp;- localPort</option>
	
	<option value="//api/name/performBlock:">&nbsp;&nbsp;&nbsp;&nbsp;- performBlock:</option>
	
	<option value="//api/name/progressOfReadReturningTag:bytesDone:total:">&nbsp;&nbsp;&nbsp;&nbsp;- progressOfReadReturningTag:bytesDone:total:</option>
	
	<option value="//api/name/progressOfWriteReturningTag:bytesDone:total:">&nbsp;&nbsp;&nbsp;&nbsp;- progressOfWriteReturningTag:bytesDone:total:</option>
	
	<option value="//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</option>
	
	<option value="//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:buffer:bufferOffset:tag:</option>
	
	<option value="//api/name/readDataToData:withTimeout:maxLength:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:maxLength:tag:</option>
	
	<option value="//api/name/readDataToData:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:tag:</option>
	
	<option value="//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToLength:withTimeout:buffer:bufferOffset:tag:</option>
	
	<option value="//api/name/readDataToLength:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToLength:withTimeout:tag:</option>
	
	<option value="//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</option>
	
	<option value="//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataWithTimeout:buffer:bufferOffset:tag:</option>
	
	<option value="//api/name/readDataWithTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataWithTimeout:tag:</option>
	
	<option value="//api/name/readStream">&nbsp;&nbsp;&nbsp;&nbsp;- readStream</option>
	
	<option value="//api/name/setAutoDisconnectOnClosedReadStream:">&nbsp;&nbsp;&nbsp;&nbsp;- setAutoDisconnectOnClosedReadStream:</option>
	
	<option value="//api/name/setDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegate:</option>
	
	<option value="//api/name/setDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegate:delegateQueue:</option>
	
	<option value="//api/name/setDelegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegateQueue:</option>
	
	<option value="//api/name/setIPv4Enabled:">&nbsp;&nbsp;&nbsp;&nbsp;- setIPv4Enabled:</option>
	
	<option value="//api/name/setIPv6Enabled:">&nbsp;&nbsp;&nbsp;&nbsp;- setIPv6Enabled:</option>
	
	<option value="//api/name/setPreferIPv4OverIPv6:">&nbsp;&nbsp;&nbsp;&nbsp;- setPreferIPv4OverIPv6:</option>
	
	<option value="//api/name/setUserData:">&nbsp;&nbsp;&nbsp;&nbsp;- setUserData:</option>
	
	<option value="//api/name/socket4FD">&nbsp;&nbsp;&nbsp;&nbsp;- socket4FD</option>
	
	<option value="//api/name/socket6FD">&nbsp;&nbsp;&nbsp;&nbsp;- socket6FD</option>
	
	<option value="//api/name/socketFD">&nbsp;&nbsp;&nbsp;&nbsp;- socketFD</option>
	
	<option value="//api/name/sslContext">&nbsp;&nbsp;&nbsp;&nbsp;- sslContext</option>
	
	<option value="//api/name/startTLS:">&nbsp;&nbsp;&nbsp;&nbsp;- startTLS:</option>
	
	<option value="//api/name/synchronouslySetDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegate:</option>
	
	<option value="//api/name/synchronouslySetDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegate:delegateQueue:</option>
	
	<option value="//api/name/synchronouslySetDelegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegateQueue:</option>
	
	<option value="//api/name/userData">&nbsp;&nbsp;&nbsp;&nbsp;- userData</option>
	
	<option value="//api/name/writeData:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- writeData:withTimeout:tag:</option>
	
	<option value="//api/name/writeStream">&nbsp;&nbsp;&nbsp;&nbsp;- writeStream</option>
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				



<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
</ul></li>







<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#class_methods">Class Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/CRData">CRData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/CRLFData">CRLFData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/LFData">LFData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/ZeroData">ZeroData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getHost:port:fromAddress:">getHost:port:fromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/hostFromAddress:">hostFromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/portFromAddress:">portFromAddress:</a></span></li>
	
</ul></li>



<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#instance_methods">Instance Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/acceptOnInterface:port:error:">acceptOnInterface:port:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/autoDisconnectOnClosedReadStream">autoDisconnectOnClosedReadStream</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:viaInterface:withTimeout:error:">connectToAddress:viaInterface:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:withTimeout:error:">connectToAddress:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">connectToHost:onPort:viaInterface:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:withTimeout:error:">connectToHost:onPort:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedAddress">connectedAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedHost">connectedHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedPort">connectedPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/delegate">delegate</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/delegateQueue">delegateQueue</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnect">disconnect</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnectAfterReading">disconnectAfterReading</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnectAfterReadingAndWriting">disconnectAfterReadingAndWriting</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnectAfterWriting">disconnectAfterWriting</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/enableBackgroundingOnSocket">enableBackgroundingOnSocket</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getDelegate:delegateQueue:">getDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/init">init</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:delegateQueue:">initWithDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:delegateQueue:socketQueue:">initWithDelegate:delegateQueue:socketQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithSocketQueue:">initWithSocketQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isConnected">isConnected</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isDisconnected">isDisconnected</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4">isIPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4Enabled">isIPv4Enabled</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4PreferredOverIPv6">isIPv4PreferredOverIPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6">isIPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6Enabled">isIPv6Enabled</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isSecure">isSecure</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localAddress">localAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localHost">localHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localPort">localPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/performBlock:">performBlock:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/progressOfReadReturningTag:bytesDone:total:">progressOfReadReturningTag:bytesDone:total:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/progressOfWriteReturningTag:bytesDone:total:">progressOfWriteReturningTag:bytesDone:total:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">readDataToData:withTimeout:buffer:bufferOffset:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:maxLength:tag:">readDataToData:withTimeout:maxLength:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:tag:">readDataToData:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToLength:withTimeout:tag:">readDataToLength:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">readDataWithTimeout:buffer:bufferOffset:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataWithTimeout:tag:">readDataWithTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readStream">readStream</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setAutoDisconnectOnClosedReadStream:">setAutoDisconnectOnClosedReadStream:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegate:">setDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegate:delegateQueue:">setDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegateQueue:">setDelegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPv4Enabled:">setIPv4Enabled:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPv6Enabled:">setIPv6Enabled:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setPreferIPv4OverIPv6:">setPreferIPv4OverIPv6:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setUserData:">setUserData:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socket4FD">socket4FD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socket6FD">socket6FD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socketFD">socketFD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/sslContext">sslContext</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/startTLS:">startTLS:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegate:">synchronouslySetDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegate:delegateQueue:">synchronouslySetDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegateQueue:">synchronouslySetDelegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/userData">userData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/writeData:withTimeout:tag:">writeData:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/writeStream">writeStream</a></span></li>
	
</ul></li>


			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="GCDAsyncSocket Class Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">GCDAsyncSocket Class Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Inherits from</td>
	<td class="specification-value">NSObject</td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">GCDAsyncSocket.h</td>
</tr>
						</tbody></table></div>
					
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						
						

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/init">&ndash;&nbsp;init</a></code>
		<span class="tooltip"><p>GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,<br/>
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.<br/>
This allows for maximum concurrency, while at the same time providing easy thread safety.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithSocketQueue:">&ndash;&nbsp;initWithSocketQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:delegateQueue:">&ndash;&nbsp;initWithDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:delegateQueue:socketQueue:">&ndash;&nbsp;initWithDelegate:delegateQueue:socketQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/delegate">&ndash;&nbsp;delegate</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegate:">&ndash;&nbsp;setDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegate:">&ndash;&nbsp;synchronouslySetDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/delegateQueue">&ndash;&nbsp;delegateQueue</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegateQueue:">&ndash;&nbsp;setDelegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegateQueue:">&ndash;&nbsp;synchronouslySetDelegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getDelegate:delegateQueue:">&ndash;&nbsp;getDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegate:delegateQueue:">&ndash;&nbsp;setDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegate:delegateQueue:">&ndash;&nbsp;synchronouslySetDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/autoDisconnectOnClosedReadStream">&ndash;&nbsp;autoDisconnectOnClosedReadStream</a></code>
		<span class="tooltip"><p>Traditionally sockets are not closed until the conversation is over.<br/>
However, it is technically possible for the remote enpoint to close its write stream.<br/>
Our socket would then be notified that there is no more data to be read,<br/>
but our socket would still be writeable and the remote endpoint could continue to receive our data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setAutoDisconnectOnClosedReadStream:">&ndash;&nbsp;setAutoDisconnectOnClosedReadStream:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4Enabled">&ndash;&nbsp;isIPv4Enabled</a></code>
		<span class="tooltip"><p>By default, both IPv4 and IPv6 are enabled.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPv4Enabled:">&ndash;&nbsp;setIPv4Enabled:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6Enabled">&ndash;&nbsp;isIPv6Enabled</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPv6Enabled:">&ndash;&nbsp;setIPv6Enabled:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4PreferredOverIPv6">&ndash;&nbsp;isIPv4PreferredOverIPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setPreferIPv4OverIPv6:">&ndash;&nbsp;setPreferIPv4OverIPv6:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/userData">&ndash;&nbsp;userData</a></code>
		<span class="tooltip"><p>User data allows you to associate arbitrary information with the socket.<br/>
This data is not used internally by socket in any way.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setUserData:">&ndash;&nbsp;setUserData:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/acceptOnPort:error:">&ndash;&nbsp;acceptOnPort:error:</a></code>
		<span class="tooltip"><p>Tells the socket to begin listening and accepting connections on the given port.<br/>
When a connection is accepted, a new instance of GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will be spawned to handle it,<br/>
and the socket:didAcceptNewSocket: <a href="#//api/name/delegate">delegate</a> method will be invoked.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/acceptOnInterface:port:error:">&ndash;&nbsp;acceptOnInterface:port:error:</a></code>
		<span class="tooltip"><p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the<br/>
additional option of specifying which interface to listen on.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
		<span class="tooltip"><p>Connects to the given host and port.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:withTimeout:error:">&ndash;&nbsp;connectToHost:onPort:withTimeout:error:</a></code>
		<span class="tooltip"><p>Connects to the given host and port with an optional timeout.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">&ndash;&nbsp;connectToHost:onPort:viaInterface:withTimeout:error:</a></code>
		<span class="tooltip"><p>Connects to the given host &amp; port, via the optional interface, with an optional timeout.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
		<span class="tooltip"><p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.<br/>
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:withTimeout:error:">&ndash;&nbsp;connectToAddress:withTimeout:error:</a></code>
		<span class="tooltip"><p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.<br/>
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:viaInterface:withTimeout:error:">&ndash;&nbsp;connectToAddress:viaInterface:withTimeout:error:</a></code>
		<span class="tooltip"><p>Connects to the given address, using the specified interface and timeout.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnect">&ndash;&nbsp;disconnect</a></code>
		<span class="tooltip"><p>Disconnects immediately (synchronously). Any pending reads or writes are dropped.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnectAfterReading">&ndash;&nbsp;disconnectAfterReading</a></code>
		<span class="tooltip"><p>Disconnects after all pending reads have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnectAfterWriting">&ndash;&nbsp;disconnectAfterWriting</a></code>
		<span class="tooltip"><p>Disconnects after all pending writes have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnectAfterReadingAndWriting">&ndash;&nbsp;disconnectAfterReadingAndWriting</a></code>
		<span class="tooltip"><p>Disconnects after all pending reads and writes have completed.<br/>
After calling this, the read and write methods will do nothing.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isDisconnected">&ndash;&nbsp;isDisconnected</a></code>
		<span class="tooltip"><p>Returns whether the socket is disconnected or connected.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isConnected">&ndash;&nbsp;isConnected</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedHost">&ndash;&nbsp;connectedHost</a></code>
		<span class="tooltip"><p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.<br/>
The host will be an IP address.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedPort">&ndash;&nbsp;connectedPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localHost">&ndash;&nbsp;localHost</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localPort">&ndash;&nbsp;localPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedAddress">&ndash;&nbsp;connectedAddress</a></code>
		<span class="tooltip"><p>Returns the local or remote address to which this socket is connected,<br/>
specified as a sockaddr structure wrapped in a NSData object.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localAddress">&ndash;&nbsp;localAddress</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4">&ndash;&nbsp;isIPv4</a></code>
		<span class="tooltip"><p>Returns whether the socket is IPv4 or IPv6.<br/>
An accepting socket may be both.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6">&ndash;&nbsp;isIPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isSecure">&ndash;&nbsp;isSecure</a></code>
		<span class="tooltip"><p>Returns whether or not the socket has been secured via SSL/TLS.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataWithTimeout:tag:">&ndash;&nbsp;readDataWithTimeout:tag:</a></code>
		<span class="tooltip"><p>Reads the first available bytes that become available on the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataWithTimeout:buffer:bufferOffset:tag:</a></code>
		<span class="tooltip"><p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">&ndash;&nbsp;readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></code>
		<span class="tooltip"><p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.<br/>
A maximum of length bytes will be read.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToLength:withTimeout:tag:">&ndash;&nbsp;readDataToLength:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Reads the given number of bytes.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></code>
		<span class="tooltip"><p>Reads the given number of bytes.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:tag:">&ndash;&nbsp;readDataToData:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataToData:withTimeout:buffer:bufferOffset:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:maxLength:tag:">&ndash;&nbsp;readDataToData:withTimeout:maxLength:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">&ndash;&nbsp;readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/progressOfReadReturningTag:bytesDone:total:">&ndash;&nbsp;progressOfReadReturningTag:bytesDone:total:</a></code>
		<span class="tooltip"><p>Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check).<br/>
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/writeData:withTimeout:tag:">&ndash;&nbsp;writeData:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/progressOfWriteReturningTag:bytesDone:total:">&ndash;&nbsp;progressOfWriteReturningTag:bytesDone:total:</a></code>
		<span class="tooltip"><p>Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check).<br/>
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/startTLS:">&ndash;&nbsp;startTLS:</a></code>
		<span class="tooltip"><p>Secures the connection using SSL/TLS.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/performBlock:">&ndash;&nbsp;performBlock:</a></code>
		<span class="tooltip"><p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socketFD">&ndash;&nbsp;socketFD</a></code>
		<span class="tooltip"><p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socket4FD">&ndash;&nbsp;socket4FD</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socket6FD">&ndash;&nbsp;socket6FD</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readStream">&ndash;&nbsp;readStream</a></code>
		<span class="tooltip"><p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/writeStream">&ndash;&nbsp;writeStream</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/enableBackgroundingOnSocket">&ndash;&nbsp;enableBackgroundingOnSocket</a></code>
		<span class="tooltip"><p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/sslContext">&ndash;&nbsp;sslContext</a></code>
		<span class="tooltip"><p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/hostFromAddress:">+&nbsp;hostFromAddress:</a></code>
		<span class="tooltip"><p>Extracting host and port information from raw address data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/portFromAddress:">+&nbsp;portFromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getHost:port:fromAddress:">+&nbsp;getHost:port:fromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/CRLFData">+&nbsp;CRLFData</a></code>
		<span class="tooltip"><p>A few common line separators, for use with the readDataToData:&hellip; methods.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/CRData">+&nbsp;CRData</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/LFData">+&nbsp;LFData</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/ZeroData">+&nbsp;ZeroData</a></code>
		
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Class Methods" name="class_methods"></a>
						<h2 class="subtitle subtitle-methods">Class Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/CRData" title="CRData"></a>
	<h3 class="subsubtitle method-title">CRData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)CRData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/CRLFData" title="CRLFData"></a>
	<h3 class="subsubtitle method-title">CRLFData</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>A few common line separators, for use with the readDataToData:&hellip; methods.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (NSData *)CRLFData</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>A few common line separators, for use with the readDataToData:&hellip; methods.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/LFData" title="LFData"></a>
	<h3 class="subsubtitle method-title">LFData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)LFData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/ZeroData" title="ZeroData"></a>
	<h3 class="subsubtitle method-title">ZeroData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)ZeroData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/getHost:port:fromAddress:" title="getHost:port:fromAddress:"></a>
	<h3 class="subsubtitle method-title">getHost:port:fromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)getHost:(NSString **)<em>hostPtr</em> port:(uint16_t *)<em>portPtr</em> fromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/hostFromAddress:" title="hostFromAddress:"></a>
	<h3 class="subsubtitle method-title">hostFromAddress:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Extracting host and port information from raw address data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (NSString *)hostFromAddress:(NSData *)<em>address</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Extracting host and port information from raw address data.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/portFromAddress:" title="portFromAddress:"></a>
	<h3 class="subsubtitle method-title">portFromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (uint16_t)portFromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
					</div>
					
					
					
					<div class="section section-methods">
						<a title="Instance Methods" name="instance_methods"></a>
						<h2 class="subtitle subtitle-methods">Instance Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/acceptOnInterface:port:error:" title="acceptOnInterface:port:error:"></a>
	<h3 class="subsubtitle method-title">acceptOnInterface:port:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the<br/>
additional option of specifying which interface to listen on.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnInterface:(NSString *)<em>interface</em> port:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the<br/>
additional option of specifying which interface to listen on.</p>

<p>For example, you could specify that the socket should only accept connections over ethernet,<br/>
and not other interfaces such as wifi.</p>

<p>The interface may be specified by name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or by IP address (e.g. &ldquo;192.168.4.34&rdquo;).<br/>
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that<br/>
the socket only accept connections from the local machine.</p>

<p>You can see the list of interfaces via the command line utility &ldquo;ifconfig&rdquo;,<br/>
or programmatically via the getifaddrs() function.</p>

<p>To accept connections on any interface pass nil, or simply use the <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/acceptOnPort:error:" title="acceptOnPort:error:"></a>
	<h3 class="subsubtitle method-title">acceptOnPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Tells the socket to begin listening and accepting connections on the given port.<br/>
When a connection is accepted, a new instance of GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will be spawned to handle it,<br/>
and the socket:didAcceptNewSocket: <a href="#//api/name/delegate">delegate</a> method will be invoked.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Tells the socket to begin listening and accepting connections on the given port.<br/>
When a connection is accepted, a new instance of GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will be spawned to handle it,<br/>
and the socket:didAcceptNewSocket: <a href="#//api/name/delegate">delegate</a> method will be invoked.</p>

<p>The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/autoDisconnectOnClosedReadStream" title="autoDisconnectOnClosedReadStream"></a>
	<h3 class="subsubtitle method-title">autoDisconnectOnClosedReadStream</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Traditionally sockets are not closed until the conversation is over.<br/>
However, it is technically possible for the remote enpoint to close its write stream.<br/>
Our socket would then be notified that there is no more data to be read,<br/>
but our socket would still be writeable and the remote endpoint could continue to receive our data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)autoDisconnectOnClosedReadStream</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Traditionally sockets are not closed until the conversation is over.<br/>
However, it is technically possible for the remote enpoint to close its write stream.<br/>
Our socket would then be notified that there is no more data to be read,<br/>
but our socket would still be writeable and the remote endpoint could continue to receive our data.</p>

<p>The argument for this confusing functionality stems from the idea that a client could shut down its<br/>
write stream after sending a request to the server, thus notifying the server there are to be no further requests.<br/>
In practice, however, this technique did little to help server developers.</p>

<p>To make matters worse, from a TCP perspective there is no way to tell the difference from a read stream close<br/>
and a full socket close. They both result in the TCP stack receiving a FIN packet. The only way to tell<br/>
is by continuing to write to the socket. If it was only a read stream close, then writes will continue to work.<br/>
Otherwise an error will be occur shortly (when the remote end sends us a RST packet).</p>

<p>In addition to the technical challenges and confusion, many high level socket/stream API&rsquo;s provide<br/>
no support for dealing with the problem. If the read stream is closed, the API immediately declares the<br/>
socket to be closed, and shuts down the write stream as well. In fact, this is what Apple&rsquo;s CFStream API does.<br/>
It might sound like poor design at first, but in fact it simplifies development.</p>

<p>The vast majority of the time if the read stream is closed it&rsquo;s because the remote endpoint closed its socket.<br/>
Thus it actually makes sense to close the socket at this point.<br/>
And in fact this is what most networking developers want and expect to happen.<br/>
However, if you are writing a server that interacts with a plethora of clients,<br/>
you might encounter a client that uses the discouraged technique of shutting down its write stream.<br/>
If this is the case, you can set this property to NO,<br/>
and make use of the socketDidCloseReadStream <a href="#//api/name/delegate">delegate</a> method.</p>

<p>The default value is YES.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.<br/>
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.<br/>
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:<br/>
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];<br/>
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>This method invokes connectToAdd</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:viaInterface:withTimeout:error:" title="connectToAddress:viaInterface:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:viaInterface:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given address, using the specified interface and timeout.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> viaInterface:(NSString *)<em>interface</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given address, using the specified interface and timeout.</p>

<p>The address is specified as a sockaddr structure wrapped in a NSData object.<br/>
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:<br/>
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];<br/>
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).<br/>
The interface may also be used to specify the local port (see below).</p>

<p>The timeout is optional. To not time out use a negative time interval.</p>

<p>This method will return NO if an error is detected, and set the error pointer (if one was given).<br/>
Possible errors would be a nil host, invalid interface, or socket is already connected.</p>

<p>If no errors are detected, this method will start a background connect operation and immediately return YES.<br/>
The <a href="#//api/name/delegate">delegate</a> callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>

<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing.<br/>
All read/write operations will be queued, and upon socket connection,<br/>
the operations will be dequeued and processed in order.</p>

<p>The interface may optionally contain a port number at the end of the string, separated by a colon.<br/>
This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end)<br/>
To specify both interface and local port: &ldquo;en1:8082&rdquo; or &ldquo;192.168.4.35:2424&rdquo;.<br/>
To specify only local port: &ldquo;:8082&rdquo;.<br/>
Please note this is an advanced feature, and is somewhat hidden on purpose.<br/>
You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection.<br/>
If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere.<br/>
Local ports do NOT need to match remote ports. In fact, they almost never do.<br/>
This feature is here for networking professionals using very advanced techniques.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:withTimeout:error:" title="connectToAddress:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.<br/>
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.<br/>
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given host and port.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given host and port.</p>

<p>This method invokes <a href="#//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">connectToHost:onPort:viaInterface:withTimeout:error:</a><br/>
and uses the default interface, and no timeout.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:viaInterface:withTimeout:error:" title="connectToHost:onPort:viaInterface:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:viaInterface:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given host &amp; port, via the optional interface, with an optional timeout.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> viaInterface:(NSString *)<em>interface</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given host &amp; port, via the optional interface, with an optional timeout.</p>

<p>The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).<br/>
The host may also be the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify connecting<br/>
to a service on the local machine.</p>

<p>The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).<br/>
The interface may also be used to specify the local port (see below).</p>

<p>To not time out use a negative time interval.</p>

<p>This method will return NO if an error is detected, and set the error pointer (if one was given).<br/>
Possible errors would be a nil host, invalid interface, or socket is already connected.</p>

<p>If no errors are detected, this method will start a background connect operation and immediately return YES.<br/>
The <a href="#//api/name/delegate">delegate</a> callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>

<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing.<br/>
All read/write operations will be queued, and upon socket connection,<br/>
the operations will be dequeued and processed in order.</p>

<p>The interface may optionally contain a port number at the end of the string, separated by a colon.<br/>
This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end)<br/>
To specify both interface and local port: &ldquo;en1:8082&rdquo; or &ldquo;192.168.4.35:2424&rdquo;.<br/>
To specify only local port: &ldquo;:8082&rdquo;.<br/>
Please note this is an advanced feature, and is somewhat hidden on purpose.<br/>
You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection.<br/>
If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere.<br/>
Local ports do NOT need to match remote ports. In fact, they almost never do.<br/>
This feature is here for networking professionals using very advanced techniques.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:withTimeout:error:" title="connectToHost:onPort:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given host and port with an optional timeout.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given host and port with an optional timeout.</p>

<p>This method invokes <a href="#//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">connectToHost:onPort:viaInterface:withTimeout:error:</a> and uses the default interface.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedAddress" title="connectedAddress"></a>
	<h3 class="subsubtitle method-title">connectedAddress</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the local or remote address to which this socket is connected,<br/>
specified as a sockaddr structure wrapped in a NSData object.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSData *)connectedAddress</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the local or remote address to which this socket is connected,<br/>
specified as a sockaddr structure wrapped in a NSData object.</p>

<p>See also the <a href="#//api/name/connectedHost">connectedHost</a>, <a href="#//api/name/connectedPort">connectedPort</a>, <a href="#//api/name/localHost">localHost</a> and <a href="#//api/name/localPort">localPort</a> methods.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedHost" title="connectedHost"></a>
	<h3 class="subsubtitle method-title">connectedHost</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.<br/>
The host will be an IP address.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSString *)connectedHost</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.<br/>
The host will be an IP address.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedPort" title="connectedPort"></a>
	<h3 class="subsubtitle method-title">connectedPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)connectedPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/delegate" title="delegate"></a>
	<h3 class="subsubtitle method-title">delegate</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)delegate</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/delegateQueue" title="delegateQueue"></a>
	<h3 class="subsubtitle method-title">delegateQueue</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (dispatch_queue_t)delegateQueue</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnect" title="disconnect"></a>
	<h3 class="subsubtitle method-title">disconnect</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects immediately (synchronously). Any pending reads or writes are dropped.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnect</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects immediately (synchronously). Any pending reads or writes are dropped.</p>

<p>If the socket is not already disconnected, an invocation to the socketDidDisconnect:withError: delegate method<br/>
will be queued onto the delegateQueue asynchronously (behind any previously queued delegate methods).<br/>
In other words, the disconnected delegate method will be invoked sometime shortly after this method returns.</p>

<p>Please note the recommended way of releasing a GCDAsyncSocket instance (e.g. in a dealloc method)<br/>
[asyncSocket setDelegate:nil];<br/>
[asyncSocket disconnect];<br/>
[asyncSocket release];</p>

<p>If you plan on disconnecting the socket, and then immediately asking it to connect again,<br/>
you&rsquo;ll likely want to do so like this:<br/>
[asyncSocket setDelegate:nil];<br/>
[asyncSocket disconnect];<br/>
[asyncSocket setDelegate:self];<br/>
[asyncSocket connect&hellip;];</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnectAfterReading" title="disconnectAfterReading"></a>
	<h3 class="subsubtitle method-title">disconnectAfterReading</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects after all pending reads have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReading</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects after all pending reads have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnectAfterReadingAndWriting" title="disconnectAfterReadingAndWriting"></a>
	<h3 class="subsubtitle method-title">disconnectAfterReadingAndWriting</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects after all pending reads and writes have completed.<br/>
After calling this, the read and write methods will do nothing.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReadingAndWriting</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects after all pending reads and writes have completed.<br/>
After calling this, the read and write methods will do nothing.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnectAfterWriting" title="disconnectAfterWriting"></a>
	<h3 class="subsubtitle method-title">disconnectAfterWriting</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects after all pending writes have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnectAfterWriting</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects after all pending writes have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/enableBackgroundingOnSocket" title="enableBackgroundingOnSocket"></a>
	<h3 class="subsubtitle method-title">enableBackgroundingOnSocket</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)enableBackgroundingOnSocket</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Configures the socket to allow it to operate when the iOS application has been backgrounded.<br/>
In other words, this method creates a read &amp; write stream, and invokes:</p>

<p>CFReadStreamSetProperty(<a href="#//api/name/readStream">readStream</a>, kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP);<br/>
CFWriteStreamSetProperty(<a href="#//api/name/writeStream">writeStream</a>, kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP);</p>

<p>Returns YES if successful, NO otherwise.</p>

<p>Note: Apple does not officially support backgrounding server sockets.<br/>
That is, if your socket is accepting incoming connections, Apple does not officially support<br/>
allowing iOS applications to accept incoming connections while an app is backgrounded.</p>

<p>Example usage:</p>

<ul>
<li>(void)socket:(GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> <em>)sock didConnectToHost:(NSString </em>)host port:(uint16_t)port<br/>
{<br/>
[asyncSocket performBlock:^{<br/>
[asyncSocket enableBackgroundingOnSocket];<br/>
}];<br/>
}</li>
</ul>

	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/getDelegate:delegateQueue:" title="getDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">getDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)getDelegate:(id *)<em>delegatePtr</em> delegateQueue:(dispatch_queue_t *)<em>delegateQueuePtr</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/init" title="init"></a>
	<h3 class="subsubtitle method-title">init</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,<br/>
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.<br/>
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (id)init</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,<br/>
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.<br/>
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>

<p>You MUST set a <a href="#//api/name/delegate">delegate</a> AND <a href="#//api/name/delegate">delegate</a> dispatch queue before attempting to<br/>
use the socket, or you will get an error.</p>

<p>The socket queue is optional.<br/>
If you pass NULL, GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will automatically create it&rsquo;s own socket queue.<br/>
If you choose to provide a socket queue, the socket queue must not be a concurrent queue.</p>

<p>The <a href="#//api/name/delegate">delegate</a> queue and socket queue can optionally be the same.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:delegateQueue:" title="initWithDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>aDelegate</em> delegateQueue:(dispatch_queue_t)<em>dq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:delegateQueue:socketQueue:" title="initWithDelegate:delegateQueue:socketQueue:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:delegateQueue:socketQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>aDelegate</em> delegateQueue:(dispatch_queue_t)<em>dq</em> socketQueue:(dispatch_queue_t)<em>sq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithSocketQueue:" title="initWithSocketQueue:"></a>
	<h3 class="subsubtitle method-title">initWithSocketQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithSocketQueue:(dispatch_queue_t)<em>sq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isConnected" title="isConnected"></a>
	<h3 class="subsubtitle method-title">isConnected</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isConnected</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isDisconnected" title="isDisconnected"></a>
	<h3 class="subsubtitle method-title">isDisconnected</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether the socket is disconnected or connected.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isDisconnected</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether the socket is disconnected or connected.</p>

<p>A disconnected socket may be recycled.<br/>
That is, it can used again for connecting or listening.</p>

<p>If a socket is in the process of connecting, it may be neither disconnected nor connected.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4" title="isIPv4"></a>
	<h3 class="subsubtitle method-title">isIPv4</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether the socket is IPv4 or IPv6.<br/>
An accepting socket may be both.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether the socket is IPv4 or IPv6.<br/>
An accepting socket may be both.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4Enabled" title="isIPv4Enabled"></a>
	<h3 class="subsubtitle method-title">isIPv4Enabled</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>By default, both IPv4 and IPv6 are enabled.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4Enabled</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>By default, both IPv4 and IPv6 are enabled.</p>

<p>For accepting incoming connections, this means GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> automatically supports both protocols,<br/>
and can simulataneously accept incoming connections on either protocol.</p>

<p>For outgoing connections, this means GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> can connect to remote hosts running either protocol.<br/>
If a DNS lookup returns only IPv4 results, GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will automatically use IPv4.<br/>
If a DNS lookup returns only IPv6 results, GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will automatically use IPv6.<br/>
If a DNS lookup returns both IPv4 and IPv6 results, the preferred protocol will be chosen.<br/>
By default, the preferred protocol is IPv4, but may be configured as desired.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4PreferredOverIPv6" title="isIPv4PreferredOverIPv6"></a>
	<h3 class="subsubtitle method-title">isIPv4PreferredOverIPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4PreferredOverIPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6" title="isIPv6"></a>
	<h3 class="subsubtitle method-title">isIPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6Enabled" title="isIPv6Enabled"></a>
	<h3 class="subsubtitle method-title">isIPv6Enabled</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6Enabled</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isSecure" title="isSecure"></a>
	<h3 class="subsubtitle method-title">isSecure</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not the socket has been secured via SSL/TLS.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isSecure</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not the socket has been secured via SSL/TLS.</p>

<p>See also the startTLS method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/localAddress" title="localAddress"></a>
	<h3 class="subsubtitle method-title">localAddress</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSData *)localAddress</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localHost" title="localHost"></a>
	<h3 class="subsubtitle method-title">localHost</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)localHost</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localPort" title="localPort"></a>
	<h3 class="subsubtitle method-title">localPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)localPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/performBlock:" title="performBlock:"></a>
	<h3 class="subsubtitle method-title">performBlock:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)performBlock:(dispatch_block_t)<em>block</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>

<p>For example, the socket file descriptor.<br/>
File descriptors are simply integers which reference an index in the per-process file table.<br/>
However, when one requests a new file descriptor (by opening a file or socket),<br/>
the file descriptor returned is guaranteed to be the lowest numbered unused descriptor.<br/>
So if we&rsquo;re not careful, the following could be possible:</p>

<ul>
<li>Thread A invokes a method which returns the socket&rsquo;s file descriptor.</li>
<li>The socket is closed via the socket&rsquo;s internal queue on thread B.</li>
<li>Thread C opens a file, and subsequently receives the file descriptor that was previously the socket&rsquo;s FD.</li>
<li>Thread A is now accessing/altering the file instead of the socket.</li>
</ul>


<p>In addition to this, other variables are not actually objects,<br/>
and thus cannot be retained/released or even autoreleased.<br/>
An example is the <a href="#//api/name/sslContext">sslContext</a>, of type SSLContextRef, which is actually a malloc&rsquo;d struct.</p>

<p>Although there are internal variables that make it difficult to maintain thread-safety,<br/>
it is important to provide access to these variables<br/>
to ensure this class can be used in a wide array of environments.<br/>
This method helps to accomplish this by invoking the current block on the socket&rsquo;s internal queue.<br/>
The methods below can be invoked from within the block to access<br/>
those generally thread-unsafe internal variables in a thread-safe manner.<br/>
The given block will be invoked synchronously on the socket&rsquo;s internal queue.</p>

<p>If you save references to any protected variables and use them outside the block, you do so at your own peril.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/progressOfReadReturningTag:bytesDone:total:" title="progressOfReadReturningTag:bytesDone:total:"></a>
	<h3 class="subsubtitle method-title">progressOfReadReturningTag:bytesDone:total:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check).<br/>
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (float)progressOfReadReturningTag:(long *)<em>tagPtr</em> bytesDone:(NSUInteger *)<em>donePtr</em> total:(NSUInteger *)<em>totalPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check).<br/>
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/progressOfWriteReturningTag:bytesDone:total:" title="progressOfWriteReturningTag:bytesDone:total:"></a>
	<h3 class="subsubtitle method-title">progressOfWriteReturningTag:bytesDone:total:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check).<br/>
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (float)progressOfWriteReturningTag:(long *)<em>tagPtr</em> bytesDone:(NSUInteger *)<em>donePtr</em> total:(NSUInteger *)<em>totalPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check).<br/>
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:" title="readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If maxLength is zero, no length restriction is enforced.<br/>
Otherwise if maxLength bytes are read without completing the read,<br/>
it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError.<br/>
The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>

<p>If you pass a maxLength parameter that is less than the length of the data (separator) parameter,<br/>
the method will do nothing (except maybe print a warning), and the delegate will not be called.<br/>
If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing (except maybe print a warning), and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while the socket is using it.<br/>
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer via<br/>
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.<br/>
If you&rsquo;re developing your own custom protocol, be sure your separator can not occur naturally as<br/>
part of the data between separators.<br/>
For example, imagine you want to send several small documents over a socket.<br/>
Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.<br/>
In this particular example, it would be better to use a protocol similar to HTTP with<br/>
a header that includes the length of the document.<br/>
Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>

<p>The given data (separator) parameter should be immutable.<br/>
For performance reasons, the socket will retain it, not copy it.<br/>
So if it is immutable, don&rsquo;t modify it while the socket is using it.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:" title="readDataToData:withTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:buffer:bufferOffset:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing (except maybe print a warning), and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while the socket is using it.<br/>
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer via<br/>
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.<br/>
If you&rsquo;re developing your own custom protocol, be sure your separator can not occur naturally as<br/>
part of the data between separators.<br/>
For example, imagine you want to send several small documents over a socket.<br/>
Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.<br/>
In this particular example, it would be better to use a protocol similar to HTTP with<br/>
a header that includes the length of the document.<br/>
Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>

<p>The given data (separator) parameter should be immutable.<br/>
For performance reasons, the socket will retain it, not copy it.<br/>
So if it is immutable, don&rsquo;t modify it while the socket is using it.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:maxLength:tag:" title="readDataToData:withTimeout:maxLength:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:maxLength:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If maxLength is zero, no length restriction is enforced.<br/>
Otherwise if maxLength bytes are read without completing the read,<br/>
it is treated similarly to a timeout - the socket is closed with a GCDAsyncSocketReadMaxedOutError.<br/>
The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>

<p>If you pass nil or zero-length data as the &ldquo;data&rdquo; parameter,<br/>
the method will do nothing (except maybe print a warning), and the <a href="#//api/name/delegate">delegate</a> will not be called.<br/>
If you pass a maxLength parameter that is less than the length of the data parameter,<br/>
the method will do nothing (except maybe print a warning), and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.<br/>
If you&rsquo;re developing your own custom protocol, be sure your separator can not occur naturally as<br/>
part of the data between separators.<br/>
For example, imagine you want to send several small documents over a socket.<br/>
Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.<br/>
In this particular example, it would be better to use a protocol similar to HTTP with<br/>
a header that includes the length of the document.<br/>
Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>

<p>The given data (separator) parameter should be immutable.<br/>
For performance reasons, the socket will retain it, not copy it.<br/>
So if it is immutable, don&rsquo;t modify it while the socket is using it.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:tag:" title="readDataToData:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If you pass nil or zero-length data as the &ldquo;data&rdquo; parameter,<br/>
the method will do nothing (except maybe print a warning), and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.<br/>
If you&rsquo;re developing your own custom protocol, be sure your separator can not occur naturally as<br/>
part of the data between separators.<br/>
For example, imagine you want to send several small documents over a socket.<br/>
Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.<br/>
In this particular example, it would be better to use a protocol similar to HTTP with<br/>
a header that includes the length of the document.<br/>
Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>

<p>The given data (separator) parameter should be immutable.<br/>
For performance reasons, the socket will retain it, not copy it.<br/>
So if it is immutable, don&rsquo;t modify it while the socket is using it.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:" title="readDataToLength:withTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToLength:withTimeout:buffer:bufferOffset:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the given number of bytes.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToLength:(NSUInteger)<em>length</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the given number of bytes.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If the length is 0, this method does nothing and the delegate is not called.<br/>
If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing, and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.<br/>
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer via<br/>
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToLength:withTimeout:tag:" title="readDataToLength:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToLength:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the given number of bytes.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToLength:(NSUInteger)<em>length</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the given number of bytes.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If the length is 0, this method does nothing and the <a href="#//api/name/delegate">delegate</a> is not called.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:" title="readDataWithTimeout:buffer:bufferOffset:maxLength:tag:"></a>
	<h3 class="subsubtitle method-title">readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.<br/>
A maximum of length bytes will be read.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.<br/>
A maximum of length bytes will be read.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, a buffer will automatically be created for you.<br/>
If maxLength is zero, no length restriction is enforced.</p>

<p>If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing, and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while the socket is using it.<br/>
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer  via<br/>
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataWithTimeout:buffer:bufferOffset:tag:" title="readDataWithTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="subsubtitle method-title">readDataWithTimeout:buffer:bufferOffset:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, the socket will create a buffer for you.</p>

<p>If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing, and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while the socket is using it.<br/>
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer via<br/>
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataWithTimeout:tag:" title="readDataWithTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">readDataWithTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the first available bytes that become available on the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the first available bytes that become available on the socket.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readStream" title="readStream"></a>
	<h3 class="subsubtitle method-title">readStream</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (CFReadStreamRef)readStream</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Provides access to the socket&rsquo;s internal CFReadStream/CFWriteStream.</p>

<p>These streams are only used as workarounds for specific iOS shortcomings:</p>

<ul>
<li><p>Apple has decided to keep the SecureTransport framework private is iOS.<br/>
This means the only supplied way to do SSL/TLS is via CFStream or some other API layered on top of it.<br/>
Thus, in order to provide SSL/TLS support on iOS we are forced to rely on CFStream,<br/>
instead of the preferred and faster and more powerful SecureTransport.</p></li>
<li><p>If a socket doesn&rsquo;t have backgrounding enabled, and that socket is closed while the app is backgrounded,<br/>
Apple only bothers to notify us via the CFStream API.<br/>
The faster and more powerful GCD API isn&rsquo;t notified properly in this case.</p></li>
</ul>


<p>See also: (BOOL)<a href="#//api/name/enableBackgroundingOnSocket">enableBackgroundingOnSocket</a></p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setAutoDisconnectOnClosedReadStream:" title="setAutoDisconnectOnClosedReadStream:"></a>
	<h3 class="subsubtitle method-title">setAutoDisconnectOnClosedReadStream:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setAutoDisconnectOnClosedReadStream:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegate:" title="setDelegate:"></a>
	<h3 class="subsubtitle method-title">setDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegate:delegateQueue:" title="setDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">setDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegate:(id)<em>delegate</em> delegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegateQueue:" title="setDelegateQueue:"></a>
	<h3 class="subsubtitle method-title">setDelegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPv4Enabled:" title="setIPv4Enabled:"></a>
	<h3 class="subsubtitle method-title">setIPv4Enabled:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPv4Enabled:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPv6Enabled:" title="setIPv6Enabled:"></a>
	<h3 class="subsubtitle method-title">setIPv6Enabled:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPv6Enabled:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setPreferIPv4OverIPv6:" title="setPreferIPv4OverIPv6:"></a>
	<h3 class="subsubtitle method-title">setPreferIPv4OverIPv6:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setPreferIPv4OverIPv6:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setUserData:" title="setUserData:"></a>
	<h3 class="subsubtitle method-title">setUserData:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setUserData:(id)<em>arbitraryUserData</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socket4FD" title="socket4FD"></a>
	<h3 class="subsubtitle method-title">socket4FD</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (int)socket4FD</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socket6FD" title="socket6FD"></a>
	<h3 class="subsubtitle method-title">socket6FD</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (int)socket6FD</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socketFD" title="socketFD"></a>
	<h3 class="subsubtitle method-title">socketFD</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (int)socketFD</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Provides access to the socket&rsquo;s file descriptor(s).<br/>
If the socket is a server socket (is accepting incoming connections),<br/>
it might actually have multiple internal socket file descriptors - one for IPv4 and one for IPv6.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/sslContext" title="sslContext"></a>
	<h3 class="subsubtitle method-title">sslContext</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (SSLContextRef)sslContext</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Provides access to the socket&rsquo;s SSLContext, if SSL/TLS has been started on the socket.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/startTLS:" title="startTLS:"></a>
	<h3 class="subsubtitle method-title">startTLS:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Secures the connection using SSL/TLS.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)startTLS:(NSDictionary *)<em>tlsSettings</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Secures the connection using SSL/TLS.</p>

<p>This method may be called at any time, and the TLS handshake will occur after all pending reads and writes<br/>
are finished. This allows one the option of sending a protocol dependent StartTLS message, and queuing<br/>
the upgrade to TLS at the same time, without having to wait for the write to finish.<br/>
Any reads or writes scheduled after this method is called will occur over the secured connection.</p>

<p>The possible keys and values for the TLS settings are well documented.<br/>
Standard keys are:</p>

<ul>
<li>kCFStreamSSLLevel</li>
<li>kCFStreamSSLAllowsExpiredCertificates</li>
<li>kCFStreamSSLAllowsExpiredRoots</li>
<li>kCFStreamSSLAllowsAnyRoot</li>
<li>kCFStreamSSLValidatesCertificateChain</li>
<li>kCFStreamSSLPeerName</li>
<li>kCFStreamSSLCertificates</li>
<li>kCFStreamSSLIsServer</li>
</ul>


<p>If SecureTransport is available on iOS:</p>

<ul>
<li>GCDAsyncSocketSSLCipherSuites</li>
<li>GCDAsyncSocketSSLProtocolVersionMin</li>
<li>GCDAsyncSocketSSLProtocolVersionMax</li>
</ul>


<p>If SecureTransport is available on Mac OS X:</p>

<ul>
<li>GCDAsyncSocketSSLCipherSuites</li>
<li>GCDAsyncSocketSSLDiffieHellmanParameters;</li>
</ul>


<p>Please refer to Apple&rsquo;s documentation for associated values, as well as other possible keys.</p>

<p>If you pass in nil or an empty dictionary, the default settings will be used.</p>

<p>The default settings will check to make sure the remote party&rsquo;s certificate is signed by a<br/>
trusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired.<br/>
However it will not verify the name on the certificate unless you<br/>
give it a name to verify against via the kCFStreamSSLPeerName key.<br/>
The security implications of this are important to understand.<br/>
Imagine you are attempting to create a secure connection to MySecureServer.com,<br/>
but your socket gets directed to MaliciousServer.com because of a hacked DNS server.<br/>
If you simply use the default settings, and MaliciousServer.com has a valid certificate,<br/>
the default settings will not detect any problems since the certificate is valid.<br/>
To properly secure your connection in this particular scenario you<br/>
should set the kCFStreamSSLPeerName property to &ldquo;MySecureServer.com&rdquo;.<br/>
If you do not know the peer name of the remote host in advance (for example, you&rsquo;re not sure<br/>
if it will be &ldquo;domain.com&rdquo; or &ldquo;www.domain.com&rdquo;), then you can use the default settings to validate the<br/>
certificate, and then use the X509Certificate class to verify the issuer after the socket has been secured.<br/>
The X509Certificate class is part of the Cocoa<a href="../Classes/AsyncSocket.html">AsyncSocket</a> open source project.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegate:" title="synchronouslySetDelegate:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegate:delegateQueue:" title="synchronouslySetDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegate:(id)<em>delegate</em> delegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegateQueue:" title="synchronouslySetDelegateQueue:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/userData" title="userData"></a>
	<h3 class="subsubtitle method-title">userData</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>User data allows you to associate arbitrary information with the socket.<br/>
This data is not used internally by socket in any way.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (id)userData</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>User data allows you to associate arbitrary information with the socket.<br/>
This data is not used internally by socket in any way.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/writeData:withTimeout:tag:" title="writeData:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">writeData:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)writeData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>

<p>If you pass in nil or zero-length data, this method does nothing and the <a href="#//api/name/delegate">delegate</a> will not be called.<br/>
If the timeout value is negative, the write operation will not use a timeout.</p>

<p>Thread-Safety Note:<br/>
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while<br/>
the socket is writing it. In other words, it&rsquo;s not safe to alter the data until after the <a href="#//api/name/delegate">delegate</a> method<br/>
socket:didWriteDataWithTag: is invoked signifying that this particular write operation has completed.<br/>
This is due to the fact that GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> does NOT copy the data. It simply retains it.<br/>
This is for performance reasons. Often times, if NSMutableData is passed, it is because<br/>
a request/response was built up in memory. Copying this data adds an unwanted/unneeded overhead.<br/>
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket<br/>
completes writing the bytes (which is NOT immediately after this method returns, but rather at a later time<br/>
when the <a href="#//api/name/delegate">delegate</a> method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/writeStream" title="writeStream"></a>
	<h3 class="subsubtitle method-title">writeStream</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (CFWriteStreamRef)writeStream</code></div>

    
</div>
						
					</div>
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2013 Dustin Voss and Robbie Hanson. All rights reserved. (Last updated: 2013-04-24)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.1 (build 858)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>